---
title: "Class 14: RNASeq mini project"
author: "Fan Wu (PID: A15127541)"
format: pdf
toc: true
---

## Background

Here we work through a complete RNASeq analysis  project. The input data comes from a knock-down experiment of a HOX gene

## Data import

Reading the `counts` and `metadata` CSV files

```{r}
counts <- read.csv("GSE37704_featurecounts.csv", row.names = 1)
metadata <- read.csv("GSE37704_metadata.csv")
```

Check on data structure
```{r}
head(counts)
```

```{r}
head(metadata)
```

Some book-keeping ðŸ“• is required as there looks to be a mist-match between metadata and counts columns
```{r}
ncol(counts)
```
```{r}
nrow(metadata)
```
Num_row of metadata needs to match exactly w/ Num_columns of counts

Looks like we need to get ride of the first "length" column of our `counts` object.

```{r}
cleancounts <- counts[, -1]
```

```{r}
colnames(cleancounts)
```
```{r}
# a good match btw/ counts & metadata
all(metadata$id == colnames(cleancounts))
```

### Remove zero count genes

There are lots of genes w/ 0 counts. We can remove these from further analysis
```{r}
head(cleancounts)
```
```{r}
to.keep.inds <- rowSums(cleancounts) > 0
nonzero_counts <- cleancounts[to.keep.inds, ]
```

## DESeq analysis

Load the package

```{r, message=FALSE}
library(DESeq2)
```

Setup DESeq object: 1. count 2. metadata 3. design of experiment

```{r}
dds <- DESeqDataSetFromMatrix(countData = nonzero_counts,
                              colData = metadata, 
                              design = ~condition)
```

run DESeq

```{r}
dds <- DESeq(dds)
```

get results

```{r}
res <-results(dds)
```


## Data Visualization

Volcano plot

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v = 2, col = "red")
abline(v = -2, col = "red")
abline(h = -log(0.05), col = "red")
```

```{r}
library(ggplot2)

mycols <- rep("gray",nrow(res))
mycols[abs(res$log2FoldChange) > 2] <- "blue"
mycols[res$padj > 0.05] <- "gray"

ggplot(res) +
  aes(x = log2FoldChange, y = -log(res$padj)) +
  geom_point(col = mycols) +
# add threshold lines for foldchange & p-value
  geom_vline(xintercept = c(-2,2), col = "red") +
  geom_hline(yintercept = -log(0.05), col = "red")
```

## Add Annotation

Add gene symbols and entrez ids

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(x = org.Hs.eg.db,
                    key = row.names(res),
                    keytype = "ENSEMBL",
                    column = "SYMBOL")

res$entrez <- mapIds(x = org.Hs.eg.db,
                    key = row.names(res),
                    keytype = "ENSEMBL",
                    column = "ENTREZID")
```
```{r}
head(res)
```

## Pathway analysis

###KEGG pathways

Run gage analysis with KEGG

```{r, message=FALSE}
library(gage)
library(gageData)
library(pathview)
```

We need a named vector of fold-change values as input for gage
```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

```{r}
data("kegg.sets.hs")

keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

```{r}
attributes(keggres)
```
```{r}
head(keggres$less, 2)
```
```{r}
pathview(pathway.id = "hsa04110", gene.data = foldchanges)
```

![](hsa04110.pathview.png)

```{r}
pathview(pathway.id = "hsa03030", gene.data = foldchanges)
```
![](hsa03030.pathview.png)

##Gene Ontology(GO) terms

Same analysis but using GO genesets rather than KEGG
```{r}
data(go.sets.hs)
data(go.subs.hs)

# Focus on Biological Process subset of GO
gobpsets = go.sets.hs[go.subs.hs$BP]

gobpres = gage(foldchanges, gsets=gobpsets)

```

```{r}
head(gobpres$less, 4)
```

### Reactome

Lots of folks like the reactome web interface. You can also run this as on R function but lets look at the website first <https://reactome.org/> Google map for pathway analysis

The website want a text file w/ one gene symbol per line fo the genes you want to map to pathways.

select those whose p-value adjusted <= 0.05
```{r}
sig_genes <- res[res$padj <= 0.05 & !is.na(res$padj), "symbol"]
head(sig_genes)
```
and write out to a file:
```{r}
write.table(sig_genes, file="significant_genes.txt", row.names=FALSE, col.names=FALSE, quote=FALSE)
```


## Save Our Results

```{r}
write.csv(res, file = "my_results.csv")
```

