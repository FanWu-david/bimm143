---
title: "Class 12: RNASeq analysis"
author: "Fan Wu(PID: A15127541)"
format: pdf
toc: true
---

## Background
Today we will analyze some RNASeq data from Himes et al. on the effects of a common steriod(dexamethasone) on airway smooth muscle cells (ASM cells).

Our starting point is the "counts" data and "metadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without the drug).

## Data Import

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

Let's have a wee peak at these objects:

```{r}
head(counts)
```

> Q1. How many genes are in this dataset?

```{r}
nrow(counts)
```

> Q. How many different experiments (column in counts or rows in metadata) are there?

```{r}
ncol(counts)
```


```{r}
nrow(metadata)
```

> Q2. How many ‘control’ cell lines do we have?

```{r}
table(metadata$dex)

sum(metadata$dex == "control")
```

## Toy differential gene expression

To start our analysis, let's calculate the mean counts for all genes in the "control" experiments.

1. Extract all "control" columns from the `counts` object
2. Calculate the mean for all rows (i.e. genes) of these "control" column
3-4 Do the same for "treated"
5. compare these `control.mean` and `treated.mean` values

```{r}
#Step 1
control.inds <- metadata$dex == "control"
# control.inds <- grep("control", metadata$dex)
control.counts <- counts[, control.inds]

dim(control.counts)
```

>Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

`rowMeans()`

```{r}
# calculate mean of each row, i.e. gene, in "control"
control.means <- rowMeans(control.counts)
```

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
# Step 3-4
treated.inds <- metadata$dex == "treated"

treated.counts <- counts[, treated.inds]

treated.means <- rowMeans(treated.counts)
```


Store these together for each of bookkeeping as `meancounts`
```{r}
meanscounts <- data.frame(control.means, treated.means)
head(meanscounts)
```

>Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

Make a plot of control vs treated mean values for all genes
plot per point per gene
```{r}
library(ggplot2)
ggplot(meanscounts, aes(x= control.means, y = treated.means)) +
  geom_point()+
  scale_x_log10() +
  scale_y_log10()
```

Make this a log plot

```{r}
plot(meanscounts, log = "xy")
```

We often talk about metrics like "log2 fold-change"

```{r}
# control / treated
log2(10 / 10)
# log2(1) = 0, meaning no change, so `log2()` is useful in showing change
```

```{r}
log2(10/20)
```

```{r}
log2(20/10)
```

```{r}
log2(40/10)
log2(10/40)
```

Let's calculate the **log2 fold-change** for our treated over control

```{r}
meanscounts$log2fc <-
log2(meanscounts$treated.means / 
  meanscounts$control.means)
```

```{r}
head(meanscounts)
```

A common "rule of thumb" is a log2 fold-change cutoff of +2 and -2
call genes "Up regulated" or "Down regulated", when log2(x/y) = +-2 means 4 times difference

Number of upregulated genes
```{r}
sum(meanscounts$log2fc >= 2, na.rm= T)
```
Number of downregulated genes at -2 threshold
```{r}
sum(meanscounts$log2fc <= -2, na.rm= T)
```

The above data is missing the **statistical significance** evaluation of these statistics: are these changes by chance or are they caused by the drug


## DESeq2 analysis

Let's do this analysis properly and keep our inner stats nerd happy - i.e. are the differences we see btw/ drug and no drug significant, given the replicate experiments.

```{r, message = FALSE}
library(DESeq2)
```

For DESeq analysis, we need 3 things

1. count values (`contData`)
2. metadata telling us about the columns in `countData` (`colData`)
3. design of the experiment (i.e. what do you want to compare)

Our first function from DESeq2 will setup the input required for analysis by storing all these 3 things together.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata,
                              design = ~dex)
# design = ~dex means this is what we are comparing
```

The main function in DESeq2 that runs the analysis is called `DESeq()`

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

```{r}
36000 * 0.05
```

## Volcano Plot

This is a common summary result figure from these types of experiments and plot the **log2 fold-change vs the adjusted p-value.**

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v = c(-2,2), col = "red")
abline(h = -log(0.05), col = "red")
```

```{r}
log(0.1)
log(0.001)
```


## Save our results

```{r}
write.csv(res, file = "my_results.csv")
```


## Add gene annotation

To help make sense of our results, and communicate them to other folks we need to add some more annotation to our main `res` object

We will use two bioconductor packages to first map IDs to different formats, including the classic gene "symbol" gene name.

I will install these with the following commands:
`BiocManager::install("AnnotationDbi")`
`BiocManager::install("org.Hs.eg.db")`

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what is in `org.Hs.eg.db` w/ the `columns()` function: 
```{r}
columns(org.Hs.eg.db)
```

We can translate or "map" IDs between any of these 26 databases using the `mapIds()` function

```{r}
res$symbol <- mapIds(keys = row.names(res),# current IDs
                    keytype = "ENSEMBL", # the format of our IDs
                    x = org.Hs.eg.db ,# where to get mappings from
                    column = "SYMBOL" # the format/DB to map to
       )

head(res)
```
Add the mappings for "GENENAME" and "ENTREZID" (NCBI identifier), a and store as `res$genename` and `res$entrez`

```{r}
res$genename <- mapIds(keys = row.names(res),# current IDs
                    keytype = "ENSEMBL", # the format of our IDs
                    x = org.Hs.eg.db ,# where to get mappings from
                    column = "GENENAME" # the format/DB to map to
       )

res$entrez <- mapIds(keys = row.names(res),# current IDs
                    keytype = "ENSEMBL", # the format of our IDs
                    x = org.Hs.eg.db ,# where to get mappings from
                    column = "ENTREZID" # the format/DB to map to
       )

head(res)
```

## Pathway analysis
Depend on the biological question we are interested in, we will use different functional set databases

Take our different expressed genes, check for overlap of these genes w/ different pathway

There are lots of bioconductor packages to do this type of analysis, now let's just try one called **GAGE** again we need to install this if we don't have it already


```{r, message=FALSE}
library(gage)
library(gageData)
library(pathview)
```

To use **GAGE** I need two things 

- a named vector of fold-change values for our DEGs (our geneset of interest) 
- a set of pathways or genesets to use for annotation.

```{r}
x = c("david" = 5, "barry" = 10)
x
```

```{r} 
names(x)
names(x) <-c("low", "high")
x
```

```{r}
foldchanges <- res$log2FoldChange
#name by entrezid, as KEGG only speak in entrezid, not genename
names(foldchanges) <- res$entrez
head(foldchanges)
```

```{r}
#run gageData for pathway
data("kegg.sets.hs")

# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

In our results object we have: 
```{r}
attributes(keggres)
```

```{r}
head(keggres$less, 5)
```

Let's look at one of these pathways w/ our genes colored up so we can see the overlap

```{r}
pathview(pathway.id = "hsa05310" ,gene.data = foldchanges)
```

Add this pathway figure to our lab report

![](hsa05310.pathview.png)

## Save our main results

```{r}
write.csv(res, file = "myresults_annotation.csv")
```

